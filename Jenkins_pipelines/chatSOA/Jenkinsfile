pipeline {
    agent {
        kubernetes {
            inheritFrom 'build-chat'
            defaultContainer 'kubectl'
            namespace 'soa-microservices'
            serviceAccount 'chatsoa-deployer'
        }
    }

    parameters {
        string(
            name: 'TARGET_BRANCH',
            defaultValue: 'ops/jenkins-chat-improvement',
            description: 'Branch to build'
        )
        choice(
            name: 'DEPLOY_ENV',
            choices: ['none', 'dev', 'staging', 'prod'],
            description: 'Deployment environment (none = skip deploy)'
        )
    }

    environment {
        DOCKERHUB_IMAGE    = 'k-chatsoa'
        IMAGE_TAG          = "latest"
        DOCKER_BUILDKIT    = '1'
        DOCKERHUB_USERNAME = 'inestmimi123'
        GRADLE_CACHE_PATH  = '/mnt/gradle_cache'
        GRADLE_USER_HOME   = "${GRADLE_CACHE_PATH}"
        REPO_URL           = 'https://github.com/ines312692/Microservices_Social_Engagement_Architecture.git'
        WORK_DIR           = "${WORKSPACE}/chatSOA/chatSOA"
        SONARQUBE_SERVER   = 'sonarqube-local'
        RELEASE_NAME       = 'chatsoa'
        CHART_PATH         = 'helm_charts/chat-soa'
        NAMESPACE          = 'soa-microservices'
    }

    options {
        skipDefaultCheckout(true)
        timestamps()
    }

    triggers {
        githubPush()
    }

    stages {
        stage('Checkout') {
            steps {
                script {
                    try {
                        echo "Checking out branch ${params.TARGET_BRANCH}"
                        checkout([
                            $class: 'GitSCM',
                            branches: [[name: "*/${params.TARGET_BRANCH}"]],
                            userRemoteConfigs: [[url: "${REPO_URL}"]],
                            extensions: [
                                [$class: 'CloneOption', depth: 1, noTags: true, shallow: true],
                                [$class: 'LocalBranch', localBranch: "${params.TARGET_BRANCH}"],
                                [$class: 'CleanBeforeCheckout']
                            ]
                        ])
                    } catch (Exception e) {
                        echo "Checkout failed: ${e.message}"
                        currentBuild.result = 'FAILURE'
                        throw e
                    }
                }
            }
        }

        stage('Build & Unit Tests') {
            steps {
                script {
                    try {
                        echo "Running build & unit tests"
                        dir("${WORK_DIR}") {
                            sh "chmod +x ./gradlew"
                            sh "./gradlew clean assemble test --project-cache-dir=${GRADLE_CACHE_PATH}"
                        }
                    } catch (Exception e) {
                        echo "Build or tests failed: ${e.message}"
                        currentBuild.result = 'FAILURE'
                        throw e
                    }
                }
            }
        }

        stage('SonarQube Analysis') {
            steps {
                script {
                    try {
                        echo "Running SonarQube analysis"
                        dir("${WORK_DIR}") {
                            withSonarQubeEnv("${SONARQUBE_SERVER}") {
                                sh """
                                    ./gradlew sonar \
                                        -Dsonar.projectKey=chatSOA \
                                        -Dsonar.java.binaries=build/classes/java/main \
                                        -Dsonar.junit.reportPaths=build/test-results/test \
                                        -Dsonar.coverage.jacoco.xmlReportPaths=build/reports/jacoco/test/jacocoTestReport.xml
                                """
                            }
                        }
                    } catch (Exception e) {
                        echo "SonarQube analysis failed: ${e.message}"
                        currentBuild.result = 'UNSTABLE'
                    }
                }
            }
        }

        stage('Docker Build & Push') {
            steps {
                script {
                    try {
                        echo "Building Docker image and pushing to DockerHub"
                        dir("${WORK_DIR}") {
                            docker.withRegistry('https://index.docker.io/v1/', 'dockerhub-creds') {
                                def imageName = "${DOCKERHUB_USERNAME}/${DOCKERHUB_IMAGE}:${IMAGE_TAG}"
                                def appImage = docker.build(imageName, "-f Dockerfile .")

                                echo "Running security scan with Trivy"
                                sh """
                                    docker run --rm \
                                        -v /var/run/docker.sock:/var/run/docker.sock \
                                        aquasec/trivy image \
                                        --scanners vuln \
                                        --vuln-type os \
                                        --severity CRITICAL,HIGH \
                                        --exit-code 1 \
                                        --no-progress \
                                        ${imageName}
                                """
                                    appImage.push()

                            }
                        }
                    } catch (Exception e) {
                        echo "Docker build/push failed: ${e.message}"
                        currentBuild.result = 'FAILURE'
                        throw e
                    }
                }
            }
        }

        stage('Helm Deploy') {
            when { expression { params.DEPLOY_ENV != 'none' } }
            steps {
                container('helm') {
                    script {
                        try {
                            echo "Deploying with Helm to ${params.DEPLOY_ENV}"
                            sh """
                                helm upgrade --install ${RELEASE_NAME} ${CHART_PATH} \
                                  --namespace ${NAMESPACE} \
                                  --set image.repository=${DOCKERHUB_USERNAME}/${DOCKERHUB_IMAGE} \
                                  --set image.tag=${IMAGE_TAG} \
                                  -f ${CHART_PATH}/values-${params.DEPLOY_ENV}.yaml
                            """
                        } catch (Exception e) {
                            echo " Helm deploy failed: ${e.message}"
                            currentBuild.result = 'FAILURE'
                            throw e
                        }
                    }
                }
            }
        }
    }

    post {
        success {
            echo "Build & Deploy succeeded for ChatSOA"
        }
        failure {
            echo "Pipeline failed for ChatSOA"
        }
        unstable {
            echo "Build completed with warnings (UNSTABLE)"
        }
    }
}
